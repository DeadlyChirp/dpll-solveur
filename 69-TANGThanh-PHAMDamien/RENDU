                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 3 novembre 2023, 23h59

Identité
--------
Nombre de binôme: 69
Nom, prénom 1: Pham Damien
Nom, prénom 2: Tang Thanh Long


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

Oui, nous avons testé la commande make dpll et elle s'exécute sans erreurs ni warnings. 
~/Chemin/notre/Dossier/TANG/PHAM/$ make dpll
ocamlfind ocamlopt -o dpll -package str -linkpkg dimacs.ml dpll.ml

L'exécution de ./dpll sudoku-4x4.cnf nous donne également la réponse attendue, conformément aux instructions dans le fichier README.

~/Chemin/notre/Dossier/TANG/PHAM/$ ./dpll /home/pain/Documents/dpll-solveur/test-files/dimacs/SAT/sudoku-4x4.cnf 
SAT
-111 -112 113 -114 -121 -122 -123 124 -131 132 -133 -134 141 -142 -143 -144 -211 212 -213 -214 221 -222 -223 -224 -231 -232 -233 234 -241 -242 243 -244 311 -312 -313 -314 -321 322 -323 -324 -331 -332 333 -334 -341 -342 -343 344 -411 -412 -413 414 -421 -422 423 -424 431 -432 -433 -434 -441 442 -443 -444 0



---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Oui, nous avons utilisé la fonction filter_map dans notre implémentation de simplifie. 

Cette fonction nous a permis de parcourir la liste des clauses, et pour chaque clause, de vérifier si le littéral "l" est présent. 
Si c'est le cas, la clause est satisfaite et est retirée. Si "l" n'est pas présent, nous avons filtré les littéraux dans la clause pour enlever "-l" (l'opposé de "l") car il est faux, et avons ajouté la clause modifiée à la nouvelle liste de clauses.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

      Pour l'implémentation de la fonction unitaire, nous avons utilisé le pattern matching pour parcourir les clauses. Nous n'avons pas eu besoin d'utiliser ou d'écrire des fonctions auxiliaires spécifiques. Nous avons géré les cas de base directement avec le pattern matching pour identifier les clauses unitaires et les renvoyer.

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

      Pour implémenter la fonction pur, nous avons écrit une fonction récursive auxiliaire aux qui parcourt la liste des clauses. 
      Nous avons utilisé les fonctions List.partition pour séparer les littéraux positifs et négatifs, et List.map pour obtenir l'absolu des littéraux négatifs. 
      Nous avons également utilisé List.fold_left pour accumuler les littéraux purs dans une liste.

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

Les deux fonctions, solveur_split et solveur_dpll_rec, implémentent le même algorithme DPLL, mais solveur_dpll_rec est une version améliorée qui gère les cas des clauses unitaires et des littéraux purs. Par conséquent, pour une formule qui contient des clauses unitaires ou des littéraux purs, solveur_dpll_rec sera plus efficace.

Example : 
let formule = [[1]; [-1; 2]; [2; -3]]

Pour cette formule, solveur_dpll_rec détectera immédiatement la clause unitaire [1], assignera la valeur vrai à la variable correspondante, et simplifiera la formule en conséquence. D'un autre côté, solveur_split procédera par branchement dès le début, ce qui est moins efficace.


---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--
